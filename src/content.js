(() => {
  const IS_BROWSER = typeof browser !== 'undefined';
  const API = IS_BROWSER ? browser : chrome;

  let parser = null;
  let debug = false;
  let executor = null;
  let mode = 'normal'; // normal | insert | visual | visualLine
  let tempNormal = false; // from <C-O>
  let replaceMode = false; // insert-overwrite (R)
  let uiTheme = 'vim';
  let ui = null;
  let vimEnabled = true;

  function log(...args) { if (debug) console.log('[VimParser]', ...args); }

  function mapCtrlKeyName(key) {
    // Normalize control key tokens like <C-E>
    const specials = {
      ' ': 'SPACE',
      'ArrowUp': 'Up',
      'ArrowDown': 'Down',
      'ArrowLeft': 'Left',
      'ArrowRight': 'Right',
      'Escape': 'ESC',
      'Enter': 'CR',
      'Backspace': 'BS',
      'Tab': 'TAB'
    };
    if (specials[key]) return specials[key];
    if (key.length === 1) return key.toUpperCase();
    return key;
  }

  function eventToToken(e) {
    // Control key combinations
    if (e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey) {
      return `<C-${mapCtrlKeyName(e.key)}>`;
    }
    // For printable keys and single-char motions
    if (e.key.length === 1) return e.key;
    // Direct named keys we might care about
    const named = {
      'Escape': '<ESC>',
      'Enter': '<CR>',
      'Backspace': '<BS>',
      'Tab': '<TAB>'
    };
    return named[e.key] || null;
  }

  

  function findEditorDoc() {
    const editorIframe = document.querySelector('.docs-texteventtarget-iframe');
    if (editorIframe && editorIframe.contentDocument) return editorIframe.contentDocument;
    const anyIframe = document.getElementsByTagName('iframe')[0];
    if (anyIframe && anyIframe.contentDocument) return anyIframe.contentDocument;
    return document;
  }

  function attachKeyListener() {
    const doc = findEditorDoc();
    doc.addEventListener('keydown', (e) => {
      if (!vimEnabled) return; // respect global enable toggle
      // Ignore synthetic events generated by our executor to avoid recursion
      if (!e.isTrusted) return;
      const token = eventToToken(e);
      if (!token) return; // allow non-token keys like arrows to flow
      try {
        // Insert mode handling: only intercept exits and temp-normal
        if (mode === 'insert') {
          if (token === '<ESC>' || token === '<C-C>') {
            e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
            setMode('normal'); replaceMode = false;
            return;
          }
          if (token === '<C-O>') {
            // Temporary normal mode for one command
            e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
            tempNormal = true; setMode('normal');
            return;
          }
          // Replace mode: intercept printable characters and perform overwrite via executor
          if (replaceMode && e.key && e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
            e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
            try {
              executor.exec({ kind: 'command', command: { id: 'insert_replace_char', args: { char: e.key }, modes: ['insert'] }, count: 1 });
            } catch (_) {}
            return;
          }
          return; // allow typing
        }

        // In non-insert modes, suppress all tokenized keys by default
        e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();

        // ESC should be exit mode regardless of current mode
        if (token === '<ESC>') {
          executor.exec({ kind: 'command', command: { id: 'exit_mode' }, count: 1 });
          return;
        }

        const res = parser.feed(token);
        if (!res) return;

        if (res.kind === 'invalid') { if (ui) ui.setBufferText(''); return; }

        if (res.kind === 'prefix' || res.kind === 'await_char') { if (ui) ui.setBufferText((res.keys || []).join('')); log('prefix', res); return; }

        // Completed parse -> execute
        log('complete', res);
        executor.exec(res);
        if (ui) ui.setBufferText('');

        if (tempNormal) {
          tempNormal = false; setMode('insert');
        }
      } catch (err) {
        console.error('Parser error', err);
      }
    }, true);
  }

  function injectPageScript() {
    const script = document.createElement('script');
    script.src = API.runtime.getURL('page_script.js');
    document.documentElement.appendChild(script);
  }

  async function loadConfig() {
    try {
      const base = await window.loadVimMotionsConfig();
      // Read debug flag from sync (small, sync-friendly)
      try {
        API.storage.sync.get(['debug'], (data) => {
          debug = !!(data && data.debug);
          try { window.__VIM_DEBUG__ = debug; } catch (_) {}
        });
      } catch (_) {}

      // Read motionsConfig from local storage first, with a legacy sync fallback
      return new Promise((resolve) => {
        try {
          API.storage.local.get(['motionsConfig'], (localData) => {
            const finishWith = (src) => {
              if (!src) { resolve(base); return; }
              try {
                const parsed = (typeof src === 'string') ? JSON.parse(src) : src;
                resolve(parsed);
              } catch (e) {
                console.warn('Invalid motionsConfig in storage, using base file', e);
                resolve(base);
              }
            };

            if (localData && typeof localData.motionsConfig !== 'undefined') {
              finishWith(localData.motionsConfig);
            } else {
              // Legacy fallback: look in sync storage if nothing is in local
              try {
                API.storage.sync.get(['motionsConfig'], (syncData) => {
                  if (syncData && typeof syncData.motionsConfig !== 'undefined') {
                    finishWith(syncData.motionsConfig);
                  } else {
                    resolve(base);
                  }
                });
              } catch (e) {
                resolve(base);
              }
            }
          });
        } catch (e) {
          resolve(base);
        }
      });
    } catch (e) {
      console.error('Failed to load motions config', e);
      return { motions: [], operators: [], textObjects: [], operatorSelf: [], settings: {} };
    }
  }

  async function init() {
    const cfg = await loadConfig();
    parser = new window.VimMotionParser(cfg);
    log('Initialized with config', cfg);
    injectPageScript();
    attachKeyListener();
    try {
      API.storage.sync.get(['theme','enabled'], (data) => {
        try { uiTheme = (data && data.theme) ? data.theme : 'vim'; } catch (_) { uiTheme = 'vim'; }
        try { vimEnabled = (data && typeof data.enabled !== 'undefined') ? !!data.enabled : true; } catch (_) { vimEnabled = true; }
        if (ui) ui.setTheme(uiTheme);
        try { if (ui && ui.ind) ui.ind.style.display = vimEnabled ? '' : 'none'; } catch (_) {}
      });
    } catch (_) {}
    try { ui = new VimUIV2(); ui.setTheme(uiTheme); ui.setMode(mode); try { if (ui && ui.ind) ui.ind.style.display = vimEnabled ? '' : 'none'; } catch (_) {} } catch (_) {}

    // Apply settings instantly when changed from popup/advanced (no tabs permission required)
    try {
      API.storage.onChanged.addListener((changes, area) => {
        // Sync-scoped settings (small, safe to sync)
        if (area === 'sync') {
          if (changes && changes.debug) {
            try { debug = !!changes.debug.newValue; window.__VIM_DEBUG__ = debug; } catch (_) {}
            log('Debug changed via storage', debug);
          }
          if (changes && changes.theme) {
            try { uiTheme = changes.theme.newValue || 'vim'; if (ui) ui.setTheme(uiTheme); } catch (_) {}
          }
          if (changes && changes.enabled) {
            try {
              vimEnabled = !!changes.enabled.newValue;
              if (ui && ui.ind) ui.ind.style.display = vimEnabled ? '' : 'none';
            } catch (_) {}
          }
        }

        // motionsConfig can come from either sync (legacy) or local (new)
        if (changes && changes.motionsConfig) {
          try {
            const nv = changes.motionsConfig.newValue;
            if (typeof nv !== 'undefined') {
              const newCfg = (typeof nv === 'string') ? JSON.parse(nv) : nv;
              parser.setConfig(newCfg);
              parser.reset();
              log('Applied updated motions config from storage');
            } else {
              // removed: fall back to base file
              loadConfig().then((baseCfg) => {
                parser.setConfig(baseCfg);
                parser.reset();
                log('Reverted to base motions config');
              });
            }
          } catch (e) {
            console.warn('Failed to apply motionsConfig change', e);
          }
        }
      });
    } catch (_) {}

    // Allow live reload via message
    API.runtime.onMessage.addListener((msg, sender, sendResponse) => {
      if (msg && msg.action === 'reloadMotionsConfig') {
        loadConfig().then((newCfg) => {
          parser.setConfig(newCfg);
          parser.reset();
          log('Reloaded config');
          sendResponse({ ok: true });
        });
        return true;
      } else if (msg && msg.action === 'updateSettings' && msg.settings) {
        try {
          if (typeof msg.settings.debug !== 'undefined') {
            debug = !!msg.settings.debug;
            try { window.__VIM_DEBUG__ = debug; } catch (_) {}
          }
          if (typeof msg.settings.theme !== 'undefined') { uiTheme = msg.settings.theme || 'vim'; if (ui) ui.setTheme(uiTheme); }
          log('Updated debug setting', debug);
          sendResponse({ ok: true });
        } catch (e) {
          console.warn('Failed to apply settings update', e);
          sendResponse({ ok: false, error: String(e) });
        }
        return true;
      }
      return false;
    });

    // Persist last-exit position when the tab/window is closing
    try {
      window.addEventListener('beforeunload', () => {
        try { executor.exec({ kind: 'command', command: { id: 'record_last_exit' }, count: 1 }); } catch (_) {}
      });
    } catch (_) {}
  }

  // Simple mode manager used by executor
  function setMode(newMode) {
    mode = newMode;
    try { if (parser && typeof parser.setMode === 'function') parser.setMode(newMode); } catch (_) {}
    if (debug) console.log('[VimMode] ->', mode, tempNormal ? '(temp)' : '');
    try { if (ui) { ui.setTempNormal(!!tempNormal); ui.setMode(mode); ui.updateCursorStyle(); } } catch (_) {}
  }
  const modeAPI = {
    setMode: setMode,
    getMode: () => mode,
    isVisual: () => mode === 'visual' || mode === 'visualLine',
    setReplaceMode: (v) => { replaceMode = !!v; },
    getReplaceMode: () => replaceMode
  };
  // Initialize executor early so it is available in init
  executor = window.createVimExecutor(modeAPI);

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
